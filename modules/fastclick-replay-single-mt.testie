%info
Module to replay a trace with throughput and latency testing

Packets are directed towards one NIC of the "server" role using one NIC of the CLIENT and expect to receive packets back on the same NIC. There is no L3 support (ARP).

Suggested usage example in your testie (omit the prefixed "//" that prevent loop import here)

//%import@client fastclick-replay-single trace=path/to.pcap NIC=0 CLIENT_NIC=0

%config
n_retry=0
n_runs=1
require_tags=import,dpdk

%variables
PKTGEN_BURST_OUT=32
PKTGEN_REPLAY_COUNT=1
NIC=0
CLIENT_NIC=0
TRACE_TIME=8
LIMIT=1024000
GEN_THREADS=2

nolinktest=0


%late_variables
NBBUF=EXPAND( $(( ( ( $LIMIT * $GEN_THREADS ) + ($PKTGEN_BURST_OUT * 2) ) + 8192 )) )

%script deps=fastclick sudo=true delay=2
click --dpdk -c 0xf -- PKTGEN_CONFIG

%file PKTGEN_CONFIG
d :: DPDKInfo($NBBUF)

define($bout $PKTGEN_BURST_OUT)
define($INsrcmac ${client:$CLIENT_NIC:mac})
define($RAW_INsrcmac ${client:$CLIENT_NIC:raw_mac})

define($INdstmac ${server:$NIC:mac})
define($RAW_INdstmac ${server:$NIC:raw_mac})

define($ignore 0)
define($wait 2)
define($replay_count $PKTGEN_REPLAY_COUNT)
define($port ${self:$NIC:pci})
define($quick true)
define($txverbose 99)
define($rxverbose 99)

fdIN :: FromDump($trace, STOP false, TIMING false, END_AFTER $TRACE_TIME)
tdIN :: ToDPDKDevice($port, BLOCKING true, BURST $bout, VERBOSE $txverbose)


elementclass Numberise { $magic |
    input-> Strip(14) -> check :: CheckIPHeader -> StoreData(36,$magic) ->  nPacket :: NumberPacket(40) -> SetIPChecksum -> Unstrip(14) -> output
}

fdIN
	-> rwIN :: EtherRewrite($INsrcmac,$INdstmac)
	-> rr :: RoundRobinSched();

rr
  -> Numberise(\<56780001>)
  ->  EnsureDPDKBuffer
  -> replayA :: ReplayUnqueue(STOP 0, QUICK_CLONE $quick, VERBOSE true, ACTIVE true)
  -> rtA :: RecordTimestamp(N 1048576)
  -> avgSINA :: AverageCounter(IGNORE $ignore)
  -> tdIN;

rr
  -> Numberise(\<56780002>)
  ->  EnsureDPDKBuffer
  -> replayB :: ReplayUnqueue(STOP 0, QUICK_CLONE $quick, VERBOSE true, ACTIVE true)
  -> rtB :: RecordTimestamp(N 1048576)
  -> avgSINB :: AverageCounter(IGNORE $ignore)
  -> tdIN;

StaticThreadSched(replayA 0)
StaticThreadSched(replayB 1)

receiveIN :: FromDPDKDevice($port, VERBOSE $rxverbose, MAC $INsrcmac, PROMISC false)

elementclass Receiver { $mac, $dir |
    input[0]
    -> c::Classifier(0/$mac,-) //Ignore broadcasts
    -> Strip(14)
    -> CheckIPHeader
    -> magic :: Classifier(36/56780001, 36/56780002,-);

    magic[0]
    -> tsdA :: TimestampDiff(rtA)
    -> Unstrip(14)
    -> avgA :: AverageCounterMP
    -> Discard;

    magic[1]
    -> tsdB :: TimestampDiff(rtB)
    -> Unstrip(14)
    -> avgB :: AverageCounterMP
    -> Discard;

    magic[2]
    -> Print("WARNING: Unknown magic / untimestamped packet", -1)
    -> Discard;

    unt :: Print("WARNING: Untimestamped packet", -1)
    -> Discard;

    tsdA[1] -> unt;
    tsdB[1] -> unt;
}

receiveIN -> RINswitch :: Switch(2)[0] -> RIN :: Receiver($RAW_INsrcmac,"IN");


//----------------
//Link initializer
//----------------
adv0 :: FastUDPFlows(RATE 0, LIMIT -1, LENGTH 64, SRCETH $INsrcmac, DSTETH $INsrcmac, SRCIP ${client:$NIC:ip}, DSTIP ${client:$NIC:ip}, FLOWS 1, FLOWSIZE 1)
    -> advq0 :: RatedUnqueue(1)
    -> tdIN;

//Check that it received its packet from 2 outputs and emits packets on output 0 when it's the case
linkoklock :: PathSpinlock() [0]
  -> linkok :: Script(TYPE PACKET,
            write advq0.active false,
            write adv0.active false,
            return 0
            )


RINswitch[2]
    -> Classifier(0/$RAW_INsrcmac)
    -> Print -> [0]linkoklock


//-----------------

linkok ->
link_initialized :: Script(TYPE PACKET,
    print "Link initialized !",
    write RINswitch.switch -1,
    print "IN has $(NIN/nPacket.count) packets",
    write RIN/chPacket.count $(NIN/nPacket.count),
    wait 1s,

    print "Starting replay...",
    write avgSINA.reset,
    write avgSINB.reset,
    write RIN/avgA.reset,
    write RIN/avgB.reset,
    write RINswitch.switch 0 ,
    write replayA.stop $replay_count,
    write replayB.stop $replay_count,
    write replayA.active true,
    write replayB.active true
);


RINswitch[1]->Print(LATEIN) -> Discard;

DriverManager(  pause,
		pause,
                goto waitagain $(eq $nolinktest 0),
                wait 2s,
                write advq0.active false,
                write adv0.active false,
                write link_initialized.run,
                label waitagain,
                pause,
		pause,
                print "Replay finished. Waiting for last packets for $wait seconds...",
                wait $wait,
                write RINswitch.switch 1,
                print "Checking if packets are still coming in..",
                wait 2s,
                print "$(RIN/chPacket.min)/$(RIN/chPacket.max)",
                print "Rate : ",
                print $(avgSINA.link_rate),
                print $(avgSINB.link_rate),
                print $(RIN/avgA.link_rate),
                print $(RIN/avgB.link_rate),
                print "Count :",
                print $(avgSINA.count),
                print $(avgSINB.count),
                print $(RIN/avgA.count),
                print $(RIN/avgB.count),
                print "RESULT-LATENCY $(div $(add $(RIN/tsdA.average) $(RIN/tsdB.average)) 2)",
                print "RESULT-THROUGHPUT $(add $(RIN/avgA.link_rate) $(RIN/avgB.link_rate))",
                print "Mean Delay: $(tsd.average) µs",
                print "Min Delay: $(tsd.min) µs",
                print "Max Delay: $(tsd.max) µs",
                print "Delay StdDev: $(tsd.stddev) µs",
                stop);
